.. ; -*- mode:rst; -*-

====
TODO
====

Future improvements planned for XCVB.

.. contents::
..
    1  Usability Issues
      1.1  Lack of Manual
      1.2  Migration from ASDF
      1.3  Configurability of the build image
      1.4  Generalized Staged Images
      1.5  In-image loading
      1.6  Multiple BUILD.lisp files
      1.7  ASDF backend
    2  Features
      2.1  Initialization and Finalization
      2.2  Tests
    3  Internals
      3.1  Distinguish target nodes and operation nodes
      3.2  Use of Namestrings
      3.3  Error handling
      3.4  Pre-escaping
    4  Higher-level description
    5  The semantics of dependencies
      5.1  FASL vs CFASL
      5.2  Data files
    6  Building a real module system
      6.1  Bibliography
      6.2  Some advice from IRC


Usability Issues
================

This section describes usability bugs,
i.e. things that do not modify the deep semantic model of XCVB,
but are necessary to make it usable.


Lack of Manual
--------------

Document all there is to know to use XCVB in README.rest.
If README grows too big, create a separate MANUAL.rest.

There should be both a tutorial and an API specification.


Migration from ASDF
-------------------

We can already do simple cases. See doc/exscribe-migration.lisp.example.

We need to handle more complex cases involving migrating
several ASDF systems to XCVB,
or systems that rely on ASDF extensions such as
compile-time reading of data files or
dynamic creation of lisp files.

Also, we may want to document how to extend asdf-dependency-grovel.
Actually, we might be interested in tweaking asdf-dependency-grovel
into some kind of xcvb-dependency-grovel, and possibly
move all the groveling on the XCVB side.

Ideally, you should be able to simultaneously convert many systems at once,
while deciding which systems will preserve their identity,
which will be merged, etc.
Or you should be able to convert systems incrementally,
and have the converter autodetect that some ASDF dependencies
have already been converted into XCVB dependencies.
i.e. the system should be able to scan existing XCVB builds in a search path
and maintain a table of which ASDF systems
have been superseded by which available BUILD.


Configurability of the build image
----------------------------------

The user needs to be able to specify files to be loaded
and/or forms to be evaluated in the initial build image.
Most notably he needs to be able to customize his asdf:\*central-registry\*
and possibly proclaim the desired optimization settings.

Typically, this is done by a file called setup.lisp
loaded into the initial staged build image.

For a simple example, no document, see doc/exscribe-compilation.lisp.example.


Generalized Staged Images
-------------------------

Instead of ad-hoc bootstrap images, provide a general mechanism
for building images used to build further images,
and use it for the initial image.


In-image loading
----------------

Provide support for xcvb to be able to handle
compiling and loading a system into the given lisp image
(instead of relying on generated Makefiles or asd file --
or possibly by using either as a backend).

Note that this is also necessary for extensions to XCVB itself,
whereby extensions are to be loaded in the current XCVB image.
See the :load-into-xcvb extension (rename it!).

As a crock, we may use the ASDF backend to provide this feature.
Or we may just run-command a make, then unconditionally load
all the dependencies for the required module.
Or keep a hash-table of which modules have been loaded
(with which content cryptohash).


Multiple BUILD.lisp files
-------------------------

Have a search path mechanism that allows XCVB
to automatically find and register existing BUILD.lisp files.

Allow the build-requires slot to work with multiple BUILD.lisp files.
Right now, only the top-most BUILD.lisp file's build-requires slot
is properly handled, the rest are ignored.
To add this functionality, the makefile-generator will need to write
a makefile that dumps multiple intermediate cores
-- one for each BUILD.lisp's build-requires slot (if present) --
and also has multiple ${CWBRLRUN} macros
so that compilation will happen with the correct core at each step of the way.
The asd-generator will similarly need to be changed
to have one asdf module for each BUILD.lisp's build-requires slot (if present).


ASDF backend
------------

It is understood that ASDF can never fully implement
all the features required for XCVB.
Nevertheless, we should in most cases be able to do
a good enough job that with some additional discipline,
a correct XCVB module should build with ASDF as a backend.

Add support for :load-source dependencies.

Add a test suite for the ASDF backend.




Features
========

This section describes features that have to be added to XCVB.
They modify the underlying build model.


Initialization and Finalization
-------------------------------

Some code has to be run before and after file is compiled.

Before to compile a file, one may want to

  * change the readtable (or the reader)
  * set up some infrastructure (db connection)
  * initialize some meta-data tables

At the beginning of a file's compilation, one may want to

  * Insert compile-time or load-time form to be evaluated
    to dynamically initialize the module.

At the end of a file's compilation, one may want to

  * Insert compile-time or load-time form to be evaluated
    to dynamically finalize the module.

After the file is compiled, one may want to

  * save cross-reference data
  * register dynamic dependencies (i.e. "requires once-per-project instantiation of this form")
  * more generally update meta-data


Executables
-----------

When creating a standalone executable, some initializers and finalizers may have to be run as above.

If the executable needs a wrapping script, things get even trickier.

We may want to reuse cl-launch here, to leverage all the support already available.


Tests
-----

Test modules should be run when their dependencies have changed;
i.e. after they have been compiled into a FASL,
they should be loaded and create a report of whether the run was successful.
Reports can further be collected for statistics, etc.


Bootstrap
---------



Internals
=========

Distinguish target nodes and operation nodes
--------------------------------------------

An operation can create multiple targets.
A target can depend on a combination of multiple operations.
See how to make Mae Make deal with such.


Use of Namestrings
------------------

Currently, the implementation of fullnames is based on namestrings,
but that isn't portable and may cause confusion
when builder and buildee interpret some namestrings differently.
Throughout the source code there are comments that say ";NUN".
These are intended to document the use of non-portable unix namestrings.

We should eventually make that stuff portable,
using some existing library for dealing with namestrings sensibly,
mostly bypassing the unreliable CL pathnames.
Stelian Ionescu may be working on something like that soon for zeta-streams.


Error handling
--------------

We should refactor all error throwing with a call to simply-error,
using a condition defined specifically for that error.

We should also provide a nicer way of presenting errors to the end-user.
Maybe there should also be some library for that.


Pre-escaping
------------

I slashed the pre-escaping trick that sbrody used to allow for lisp files
to use ${FASL} as an extension that wouldn't be quoted for the Makefile.
We'll need to find some trick to do such things in a clean way,
if we really want to do them.


Higher-level description
========================

It's OK that we started with hand-coding the behaviour of XCVB in Lisp
but eventually, we should have a domain-specific language to describe
the structure of the dependency graph and the operations used to build it.

Note that we have to map various entities.

  A- *state*

    1- *files*, i.e. persistent state

      a- Files are divided in source files vs object files.
         Source files are sufficient to build the rest of the project.

      b- actual source files are to be version-controlled and archived,
         but configuration files count as source, but are computed or edited.

      c- object files may be deliverables or just intermediate throwables.

      d- for bootstrap purposes, the content of an object file is sometimes
         copied into a source file.

      e- Generated lisp files count as objects, not source, unless bootstrapped
         and checked in. It is necessary to have the meta-data on these files
         before a plan may be made to compile them, so either these files need
         to have static meta-data known in advance, or the planning process needs
         to be staged so that the plan will be revised when the file contents
         are known and the meta-data is available.

      f- we thus distinguish file path from file contents.
         File *contents* are pure extensional data,
         file *paths* are intentional anchors.
         In a given *checkout*, the mapping of source path to contents is a given.

    2- *worlds*, i.e. linear state

      a- there again *processes* are the intentional agents,
         whereas *process states* are the extensional states, up to some gross equivalence.

      b- by forking, we may (or may not) preserve the desired equivalent process state;
         another strategy (sometimes not available) may be to dump an image and resume from it.

  B- *plans*

    1- *operations*, i.e. atomic sets of commands to compute one set of states from others.

      a- concrete operations are nodes in the dependency graph,
      joining together input states to output states.

      b- in a given representation (i.e. Makefile, ASDF, etc.), not all operations are permitted.
         e.g. with make, you can't duplicate a process state with fork, whereas you could
         with a future native driver. Or using ECL, you can't load then dump -- you must link
         with a special process.

      c- And so whether operations are decomposed into basic elements or grouped in actionable wholes
         depends on the specific target. It may also depend on opportunities for optimization.

      d- multiple operations may lead to the "same" outcome up to equivalence.
         Operations may be combined and some combinations preferred to others.
   
    2- *operators* are methods that create concrete operations out of various parameters

      a- parameters include input file, options (which compiler/flags to use), etc.

    3- *dependencies*

      a- effective dependencies include any data that was actually consulted in building an object.
         Which dependencies were or weren't included may be discovered only after the fact.

      b-

The semantics of dependencies
=============================

FASL vs CFASL
-------------

Allow a module to depend on the cfasl of a file if it is available,
or the fasl of the file if there are no cfasls.
There is already a cfasl-or-fasl-node for this purpose
-- but the actual functionality hasn't been implemented yet.


Data files
----------

Allow a module to depend on a data-file.
That file will not be compiled or loaded into the lisp image,
but will just be used for tracking
when the file that depends on it needs to be recompiled.


Building a real module system
=============================

Bibliography
------------

Don't miss these:
  http://readscheme.org/modules/


Some advice from IRC
--------------------------

Riastradh on the irc.openprojects.net #scheme channel gave the following piece of advice.
Personally I think that it would be easiest to use Scheme48's module system for that,
but what I'd care most about is (1) that you separate phases sensibly, and
(2) that you provide working hygiene.
See Flatt, 'Composable and Compilable Macros', 2002.
http://www.cs.utah.edu/plt/publications/macromod.pdf
(The R6RS's library system emphatically got phase separation wrong.  Don't repeat their mistake.)

Rainer Joswig, suggested:
'BUILD: A tool for maintaining consistency in modular systems'
by Richard Elliot Robbins, 1985.
ftp://publications.ai.mit.edu/ai-publications/pdf/AITR-874.pdf

Also see Ruby gems, Chicken eggs, Java beans.
SCons, OMake, CMake, etc.
