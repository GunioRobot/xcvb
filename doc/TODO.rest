.. ; -*- mode:rst; -*-

====
TODO
====

Future improvements planned for XCVB.

.. contents::
..
    1  Usability
      1.1  Migration from ASDF
      1.2  In-image loading
      1.3  Multiple BUILD.lisp files
    2  Internals
      2.1  Use of Namestrings
      2.2  Error handling
      2.3  Higher-level dependency description
    3  The semantics of dependencies
      3.1  FASL vs CFASL
      3.2  Data files
    4  Building a real module system
      4.1  Bibliography
      4.2  Some advice from a schemer


Usability
=========

Migration from ASDF
-------------------

Automate and document in an example how to use asdf-dependency-grovel
and XCVB together to migrate an existing system from ASDF to XCVB.


In-image loading
----------------

Provide support for xcvb to be able to handle
compiling and loading a system into the given lisp image
(instead of relying on generated Makefiles or asd file --
or possibly by using either as a backend).

Note that this is also necessary for extensions to XCVB itself,
whereby extensions are to be loaded in the current XCVB image.
See the :load-into-xcvb extension (rename it!).


Multiple BUILD.lisp files
-------------------------

Allow the build-requires slot to work with multiple BUILD.lisp files.
Right now, only the top-most BUILD.lisp file's build-requires slot
is properly handled, the rest are ignored.
To add this functionality, the makefile-generator will need to write
a makefile that dumps multiple intermediate cores
-- one for each BUILD.lisp's build-requires slot (if present) --
and also has multiple ${CWBRLRUN} macros
so that compilation will happen with the correct core at each step of the way.
The asd-generator will similarly need to be changed
to have one asdf module for each BUILD.lisp's build-requires slot (if present).


Internals
=========

Use of Namestrings
------------------

Currently, the implementation of fullnames is based on namestrings,
but that isn't portable and may cause confusion
when builder and buildee interpret some namestrings differently.
Throughout the source code there are comments that say ";NUN".
These are intended to document the use of non-portable unix namestrings.

We should eventually make that stuff portable,
using some existing library for dealing with namestrings sensibly,
mostly bypassing the unreliable CL pathnames.
Stelian Ionescu may be working on something like that soon for zeta-streams.


Error handling
--------------

We should refactor all error throwing with a call to simply-error,
using a condition defined specifically for that error.

We should also provide a nicer way of presenting errors to the end-user.
Maybe there should also be some library for that.


Higher-level description
------------------------

It's OK that we started with hand-coding the behaviour of XCVB in Lisp
but eventually, we should have a domain-specific language to describe
the structure of the dependency graph and the operations used to build it.

Note that we have to map various entities.
A- *state*
 1- *files*, i.e. persistent state
   a- Files are divided in source files vs object files.
      Source files are sufficient to build the rest of the project.
   b- actual source files are to be version-controlled and archived,
      but configuration files count as source, but are computed or edited.
   c- object files may be deliverables or just intermediate throwables.
   d- for bootstrap purposes, the content of an object file is sometimes
      copied into a source file.
   e- Generated lisp files count as objects, not source, unless bootstrapped
      and checked in. It is necessary to have the meta-data on these files
      before a plan may be made to compile them, so either these files need
      to have static meta-data known in advance, or the planning process needs
      to be staged so that the plan will be revised when the file contents
      are known and the meta-data is available.
   f- we thus distinguish file path from file contents.
      File *contents* are pure extensional data,
      file *paths* are intentional anchors.
      In a given *checkout*, the mapping of source path to contents is a given.
 2- *worlds*, i.e. linear state
   a- there again *processes* are the intentional agents,
      whereas *process states* are the extensional states, up to some gross equivalence.
   b- by forking, we may (or may not) preserve the desired equivalent process state;
      another strategy (sometimes not available) may be to dump an image and resume from it.
B- *plans*
 1- *operations*, i.e. atomic sets of commands to compute one set of states from others.
   a- concrete operations are nodes in the dependency graph,
      joining together input states to output states.
   b- in a given representation (i.e. Makefile, ASDF, etc.), not all operations are permitted.
      e.g. with make, you can't duplicate a process state with fork, whereas you could
      with a future native driver. Or using ECL, you can't load then dump -- you must link
      with a special process.
   c- And so whether operations are decomposed into basic elements or grouped in actionable wholes
      depends on the specific target. It may also depend on opportunities for optimization:

 2- *operators* are methods that create concrete operations out 
 3- 
 2- *plans*
   a- a plan is a graph of operations 

   - multiple operations may lead to the "same" outcome up to equivalence.
      Operations may be combined and some combinations preferred to others.
   a- we need to have various representations of the above,
      vs actually acting on the representation.




The semantics of dependencies
=============================

FASL vs CFASL
-------------

Allow a module to depend on the cfasl of a file if it is available,
or the fasl of the file if there are no cfasls.
There is already a cfasl-or-fasl-node for this purpose
-- but the actual functionality hasn't been implemented yet.


Data files
----------

Allow a module to depend on a data-file.
That file will not be compiled or loaded into the lisp image,
but will just be used for tracking
when the file that depends on it needs to be recompiled.


Building a real module system
=============================

Bibliography
------------

Don't miss these:
  http://readscheme.org/modules/


Some advice from a schemer
--------------------------

Riastradh on #scheme:
Personally I think that it would be easiest to use Scheme48's module system for that,
but what I'd care most about is (1) that you separate phases sensibly, and
(2) that you provide working hygiene.
See Flatt, `Composable and Compilable Macros', 2002.
	http://www.cs.utah.edu/plt/publications/macromod.pdf
(The R6RS's library system emphatically got phase separation wrong.  Don't repeat their mistake.)

