.. ; -*- mode:rst; -*-

==============
XCVB Internals
==============

This file describes the current internals of XCVB.

Unless you check it out as of an official major release as tagged in git,
it may or may not be up to date.


.. contents::
..
    1  Current Files
      1.1   driver.lisp
      1.2   pkgdcl.lisp
      1.3   macros.lisp
      1.4   utilities.lisp
      1.5   specials.lisp
      1.6   logging.lisp
      1.7   grains.lisp
      1.8   computations.lisp
      1.9   portablish-pathnames.lisp
      1.10  registry.lisp
      1.11  lisp-invocation.lisp
      1.12  extract-target-properties.lisp
      1.13  lisp-grain.lisp
      1.14  names.lisp
      1.15  search-path.lisp
      1.16  dependencies-interpreter.lisp
      1.17  static-backends.lisp
      1.18  string-escape.lisp
      1.19  makefile-backend.lisp
      1.20  asdf-converter.lisp
      1.21  main.lisp
    2  Good places to extend XCVB
      2.1  Extending the driver
      2.2  Simple dispatchers as extension points
      2.3  Enriching the system
      2.4  Dynamic XCVB extensions
    3  Notes
      3.1  Fullnames
      3.2  Eager vs Lazy Module Scanning
      3.3  Filesystem Access
      3.4  TODO


Current Files
=============

General TODO: remove cruft.

driver.lisp
-----------

A small collection of utilities to be compiled into buildee processes
so as to provide an abstraction layer for XCVB to compile files.

Assuming ASDF is already loaded, the driver will also include
ASDF-specific extensions, including the ability to load ASDF systems
and to determine whether or not ASDF systems need to be re-compiled.

Therefore, you must make sure to load ASDF *before* the driver
if you want the XCVB to properly support ASDF in the target system.


pkgdcl.lisp
-----------

This file creates the XCVB package and exports the necessary symbols.

TODO: before we release, edit this file and make sure that
we export all those defined symbols that we want users to use,
and only those symbols.


macros.lisp
-----------

A collection of general-purpose macros.

TODO: Most of them should be moved to a library that XCVB would depend upon.


utilities.lisp
--------------

A collection of utility functions.
Also defines many conditions.

TODO: move conditions to another file.

TODO: Most utilities should be moved to a library that XCVB would depend upon.


specials.lisp
-------------

A collection of global variables,
many of which can be used to customize the behavior of the user-visible parts XCVB.


logging.lisp
------------

A trivial facility for logging messages directed to the user,
depending on a varying degree of verbosity.


grains.lisp
-----------

Definition of the main datastructures of XCVB and helper functions.

Grains are nodes in the planning graph representing
files, phonies or transient states,
and as far as the Makefile backend goes, correspond to Makefile targets.

For other backends, grains may be a more general state,
including things like "a running image where such libraries are loaded".
They are named "grains" after reading
'BUILD: A tool for maintaining consistency in modular systems'
by Richard Elliot Robbins, 1985.
ftp://publications.ai.mit.edu/ai-publications/pdf/AITR-874.pdf


computations.lisp
-----------------

Computations are nodes in the planning graph
representing computations that thake some grains as input
and create some other grains as output.
In the Makefile backend, they correspond to the Makefile rules.


portablish-pathnames.lisp
-------------------------

Abstraction layer to ensure that XCVB uses reasonably portable names when naming modules.

Everywhere that hierarchical module names are involved,
XCVB uses the "``/``" character as a pathname directory separator,
in a way that is guaranteed to work portably, however things may vary depending on
Lisp implementation, Operating system, pathname host and device.
Also, XCVB will only accept module names where all characters are valid: ``[-_.,A-Za-z0-9]``.

We might eventually be using some existing library for dealing with namestrings sensibly,
mostly bypassing the unreliable CL pathnames.
Stelian Ionescu may be working on something like that soon for zeta-streams.
In the meantime, we'll use our own library portablish-pathnames
to get rid of these non-portable things.


registry.lisp
-------------

Handles the mapping from fullname to grain,
and conflicts when multiple builds claim the same name.


lisp-invocation.lisp
--------------------

Handles the invocation of the target lisp system,
abstracting away the differences between implementations.


extract-target-properties.lisp
------------------------------

Functions to extract from the target Lisp (the one that will run code)
various information such as the ``*features*``,
whether CFASLs are supported, etc.


lisp-grain.lisp
---------------

Handles parsing module forms in lisp grains,
including the naming of other modules within a module form.


names.lisp
----------

Handles the mapping from file to fullname and fullname to file.
This includes recursing in the case that the fullname is
inherited from a build.xcvb up the filesystem tree.


search-path.lisp
----------------

Handles the search path where XCVB goes looking for available builds.
Shell variable ``XCVB_PATH`` or Lisp variable ``xcvb:*search-path*``.


dependencies-interpreter.lisp
-----------------------------

This file contains the substance of XCVB's dependency little language,
independently from the backend being used.


static-backends.lisp
--------------------

Builds a static graph, for use with GNU Make, ASDF, and other static backends.


string-escape.lisp
------------------

Handles escaping strings, for use in shell invocations and/or
``Makefile`` commands.


makefile-backend.lisp
---------------------

This is our new makefile backend,
iterating over computations to create Makefile rules.


asdf-converter.lisp
-------------------

This file contains the code to take an ASDF system
and write a build.xcvb file for it
and add module forms to the top of all the source files in the system,
so that XCVB can now be used to compile the system.

The entry point to this file is the function ASDF-TO-XCVB,
(or the corresponding command-line command).
It take as a parameter one SYSTEM or a list of several SYSTEMS
to merge and convert together so they may be built with XCVB.
The converter will first use ``asdf-dependency-grovel``
to compute the actual dependencies within your system(s),
thus generating a list of components;
then it will then process that list of components
and create or update a build.xcvb and update all source files
to insert a module statement,
keeping any manual rules from a previously added module statement
but otherwise overriding the main data.


main.lisp
---------

The main entry file,
with XCVB's command-line interface.



Good places to extend XCVB
==========================

Extending the driver
--------------------

So as to remain minimal, the ``driver`` includes a cruder mechanism
for the semantics of its command language: the macro ``run``
maps keywords to functions by looking for the function definition
of a symbol of the same name as given keyword in the package ``:xcvb-driver``.

Therefore, to extend the command language for the driver's command language,
just define functions in said package, and make sure the files defining these
functions are loaded before these commands are used
(e.g. by listing them first in dependencies).


Simple dispatchers as extension points
--------------------------------------

XCVB defines many extensible "little languages"
that are processed through uses of the macro ``define-simple-dispatcher``.
These little-languages are built atop the SEXP-syntax:
an element is either an atom or list;
the dispatching function distinguishes atom from lists;
atoms have their own semantic function;
the semantics of a list is dispatched to a function
that depends on the head of the list
(its first element, usually a keyword).
Semantic functions take as first argument an environment,
and the rest of their arguments is whatever follows the head of the list.

If you want extensibility for the atom semantic function,
you can use a CLOS generic function.
However, for easy readability and debuggability,
most of the existing code tries to use
simple languages that only use lists, keywords and strings
as inputs and outputs of the various functions.
We propose that you should stick to this convention for now.


Enriching the system
--------------------

The simplest such extension point is ``normalize-dependency``
in ``dependencies-interpreter.lisp``.
Its input is utterances in the input language for dependencies,
and its output is utterances in a restricted variant of this language
where names are resolved:
names do not depend anymore on the context of the grain
in which they were uttered,
build names are distinguished from fasl names,
superseded ASDF systems are replaced by superseding builds.
When you wish to add a new type of dependencies to the input language,
you'll need to extend this function.

If you wish to extend the output language,
you'll similarly need to extend the "simple dispatchers"
that process this output language,
currently the simple-dispatchers ``load-command-for``
and ``dependency-namestring``.
That will probably also mean adding new graph nodes,
with appropriate simple-dispatchers in ``static-backends.lisp``
and ``makefile-backend.lisp``.

Finally, we have reserved a place for "extension forms" in the module syntax.
Currently, we just use it for an experimental way to have generated files in XCVB.
See the simple-dispatcher for ``handle-extension-form``.

Along the way, you may have to modify more files,
maybe create an additional one for your feature,
maybe create more little languages, more simple-dispatchers,
more global data-structures.


Dynamic XCVB extensions
-----------------------

The "X" of "XCVB", while not completely a lie,
is not very developed at this time.

If you have the need for dynamic extensions, though,
it would be easy enough to provide a command line interface
for loading new code before to re-process the rest of the command-line arguments.
The new code could extend or override existing simple-dispatchers,
define new functions, push new command-line handlers.
Loading extensions could also be done as part of parsing build modules.


Notes
=====

Fullnames
---------

A fullname is used as a unique name
to specify a component in the system.
Both modules and nodes have fullnames --
usually a node will have the same fullname as the module it was generated from
modulo a different file extension.


Eager vs Lazy Module Scanning
-----------------------------

There are two ways that the search path may be search for modules,
and we have to choose early on because of the naming implications.

In the eager scanning approach,
the search paths are scanned for build modules
at the beginning of the build session,
avoiding recursion into version control repositories
or other excluded patterns.

In the lazy scanning approach, the search paths are scanned
only when a specific module is requested,
and the path to scan relative to directories in the search path
can be deduced trivially from the module specification,
so only a small number of candidate paths need to be searched
at any time.

In the eager approach,
the mapping from module name to pathname could be arbitrary,
developers or system integrators
would be free to organize their sources as they wish
and could easily override installed modules
with the specific versions they need,
without having to mimic a standard installation
by moving things around or by using symlinks.
Significant long hierarchical names could be used
to disambiguate modules globally
(but shorter nicknames could also be used if non-ambiguous).
What would make a module toplevel would be the fact
that it declares such a fullname.
The downside would be that eager scanning
introduces two levels of complexity.
The first complexity is this naming indirection,
whereby the whole hierarchy of installed modules
would have to be scanned at every build,
or a cache of the module map would have to be maintained
with timestamp information.
The second complexity is the fact that eager scanning
requires lazy evaluation of the scanned modules,
least the whole Lisp world needs be planned for
(and conflicts resolved) everytime anything is built;
it must be possible to extract naming information from
the module declarations without evaluating any of the
computations required to otherwise make sense of the module.

The lazy approach is much simpler,
at the cost of constraining developers and/or system integrators
to agree on a file hierarchy for their modules.
This cost seems to be paid happily by developers of
Perl, OCaml, Python, PLT Scheme, and many more languages,
so it isn't that high.
In this approach, what makes a module toplevel is simply that
it's located at the top of a directory in the search-path.

The lazy approach allows to better scale to compilation of software
using larger sets of libraries when each piece of software only
uses a small subset of the libraries.
It corresponds to what ASDF currently does.
However, it seems harder to program,
especially if we are to scan whole filesystem hierarchies
and still handle conflicts gracefully;
it is harder to configure if we are to avoid symlinks all over the place
without forcing things into a centralized hierarchy like other languages do;
and it opens a larger window to race conditions
creating unpredictable behaviour if libraries are
tweaked in the middle of a run.

On the other hand, the eager approach seems to better fit
the destructured way that Common Lispers currently work
with respect to filesystem organization (as with other topics)
and may be a double pain (socially speaking) to first reject
then to retrofit after the fact if we find it's required.
Attila Lendvai notably favors the eager approach
(which was also my initial reflex).


Filesystem Access
-----------------

We currently use standard CL functions such as DIRECTORY to find build files.

We don't use CL-FAD because it is broken,
and fixing it is an uphill battle that requires code for each implementation,
each time with many system-dependent variants.

If we ever require deeper access to the filesystem
(e.g. to manipulate timestamps, symlinks, etc.),
we should be using IOLib.
IOLib is not perfect, but to fix it you only need code for each OS,
and there is a dwindling number of relevant OSes;
implementation interactions are already handled by CFFI.
So, if we ever port XCVB to anything else than Unix,
the correct way will be to grow Windows (and JVM, Genera) support in IOLib.
See my rant "Who's responsible for that moving part?":
http://fare.livejournal.com/139755.html


TODO
----

For issues and TODO items, see TODO.rest.
