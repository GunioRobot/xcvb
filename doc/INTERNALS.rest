.. ; -*- mode:rst; -*-

==============
XCVB Internals
==============

This file describes the current internals of XCVB.

Unless you check it out as of an official release as tagged in git,
it may or may not be up to date.

(As massive refactoring is underway, this document is found lacking.
Send inquiries to the mailing-list if you need it to be updated.)


.. contents::
..
    1  Files
      1.1   driver.lisp
      1.2   asdf-extensions.lisp
      1.3   pkgdcl.lisp
      1.4   macros.lisp
      1.5   utilities.lisp
      1.6   specials.lisp
      1.7   grains.lisp
      1.8   portablish-pathnames.lisp
      1.9   names.lisp
      1.10  registry.lisp
      1.11  search-path.lisp
      1.12  lisp-grain.lisp
      1.13  lisp-invocation.lisp
      1.14  string-escape.lisp
      1.15  asdf-extensions.lisp
      1.16  extensions.lisp
      1.17  xcvb.lisp
      1.18  traverse.lisp
      1.19  makefile-generator.lisp
      1.20  asd-generator.lisp
      1.21  asdf-converter.lisp
      1.22  main.lisp
    2  Good places to extend XCVB
    3  Notes
      3.1  Fullnames
      3.2  Eager vs Lazy Module Scanning
      3.3  Random Remarks
      3.4  TODO


Files
=====

driver.lisp
-----------

A small collection of utilities to be compiled into buildee processes
so as to provide an abstraction layer for XCVB.


asdf-extensions.lisp
--------------------

This file adds a function in the asdf package
to determine whether or not an asdf system needs to be re-compiled.


pkgdcl.lisp
-----------

This file creates the XCVB package and exports the necessary symbols.


macros.lisp
-----------

A collection of general-purpose macros.
Most of them should be moved to a library that XCVB would depend upon.


utilities.lisp
--------------

A collection of utility functions.
Most of them should be moved to a library that XCVB would depend upon.

Also defines many conditions (TODO: move them to another file).


specials.lisp
-------------

A collection of global variables,
many of which can be used to customize the behavior of the user-visible parts XCVB.


grains.lisp
-----------

Definition of the main datastructures of XCVB and helper functions.
Named grains after reading
'BUILD: A tool for maintaining consistency in modular systems'
by Richard Elliot Robbins, 1985.
ftp://publications.ai.mit.edu/ai-publications/pdf/AITR-874.pdf


lisp-invocation.lisp
--------------------

Handles the invocation of the target lisp system.


computations.lisp
-----------------

Computations from (set of) grains to (set of) grains.


portablish-pathnames.lisp
-------------------------

Abstraction layer to ensure that XCVB uses reasonably portable names when naming modules.

Everywhere that hierarchical module names are involved,
XCVB uses the "``/``" character as a pathname directory separator,
in a way that is guaranteed to work portably, however things may vary depending on
Lisp implementation, Operating system, pathname host and device.
Also, XCVB will only accept module names where all characters are valid: ``[-_.,A-Za-z0-9]``.


Use of Namestrings [V1]
-----------------------

Currently, the implementation of fullnames is based on namestrings,
but that isn't portable and may cause confusion
when builder and buildee interpret some namestrings differently.
Throughout the source code there are comments that say ";NUN".
These are intended to document the use of non-portable unix namestrings.

We should eventually make that stuff portable,
using some existing library for dealing with namestrings sensibly,
mostly bypassing the unreliable CL pathnames.
Stelian Ionescu may be working on something like that soon for zeta-streams.
In the meantime, we'll use our own library portablish-pathnames
to get rid of these non-portable things.




names.lisp
----------

Handles the mapping from file to fullname,
including recursing in the case that the fullname is
inherited from a BUILD.lisp up the filesystem tree.


registry.lisp
-------------

Handles the mapping from fullname to grain,
and conflicts when multiple BUILDs claim the same name.


search-path.lisp
----------------

Handles the search path.


lisp-grain.lisp
---------------

Handles parsing module forms in lisp grains,
including the naming of other modules within a module form.


fasl-grain.lisp
---------------

Handles the compiling of lisp grains into fasl grains.


string-escape.lisp
------------------

Handles escaping strings, for use in shell invocations and/or
``Makefile`` commands.


asdf-dependencies.lisp
----------------------

Support for dependencies upon ASDF systems.


static-backends.lisp
--------------------

Builds a static graph, for use with GNU Make, ASDF, and other static backends.


extensions.lisp
---------------

OBSOLETE: this file and associated functionality should be replaced
by some proper build language, inspired by OMake(?).

This file contains the defextension macro
and a couple of pre-defined extensions.

The defextension macro defines a function and specifies a keyword
that can be used to specify that function
in the extension forms part of a module declaration.
The extension functions from a module form are applied
right after the module form has been parsed into a module object.


xcvb.lisp
---------

OBSOLETE: this file is a remnant from XCVB 0.11 and
will be replaced by other files.
It still contains the code that used to construct the dependency graph.

The main entry point into this file is through the functions
create-dependency-graph and create-dump-image-graph.
Both of these take a pathspec for the source file
whose dependency graph is being created.
They will read the module form from the top of the source file,
and create a module object to represent it.
Then a lisp-image-node will be created
to represent a lisp image with the fasl for the given source-file loaded.
The lisp-image-node will have one compile-dependency:
the fasl-node for the given source file.
It then uses the function create-dependency-node
to create nodes of the proper type for each of that file's dependencies.
The function create-dependency-node destructures
the dependency list from the module for the file
and uses the generic function create-dependency-node-from-type
to create a dependency-graph-node of the proper type
for each of the node's dependencies.
This process will repeat recursively
until the whole dependency graph is created.
If you add a new type of dependency-graph-node,
it is important to create a new method on create-dependency-node-from-type
so that there is a way to specify that type of dependency
in a module declaration.


traverse.lisp
-------------

OBSOLETE: will be replaced as I refactor the grain API.

This file contains the function traverse,
as composed from a collection of methods.
It provides a couple of different ways
of topologically sorting the dependency graph.

It probably should be refactored to be automatically deduced
from a higher-level description of the operators underlying
the creation of the graph.


makefile-generator.lisp
-----------------------

OUT-OF-DATE: should be rewritten as part of our refactoring.

This file contains the code to take a dependency graph
and write a Makefile that can be used by make
to compile the system specified by the graph.
The entry point to this file should be the write-makefile function.
This function takes the path to a lisp source file,
and will construct a dependency graph for that file,
then write a makefile in the directory specifed by output-path
that will be able to compile the system.
The generated makefile starts by using the specified lisp executable
(as specified in compiler-options.lisp)
to dump an image with XCVB loaded,
along with any other files/systems that are specified
in the build-requires slot of the module for the BUILD.lisp file
that is associated with the source file whose dependency graph
is being written to the makefile.


asd-generator.lisp
------------------

OUT-OF-DATE: should be rewritten as part of our refactoring.

This file contains the code to take a dependency graph
and write an asd file that can be used by asdf
to compile the system specified by the graph.
The entry point for this file should be the write-asd-file function.
The generated asd file will have one asdf module
to load all the files/systems in the build-requires slot
of the global build-module,
and another module -- which depends on the first module --
for all the other files/systems.

The conversion to ASDF is lossy and the Makefile target
should be preferred for development purposes,
but the ASDF target should be good enough for deployment purposes
when providing backwards compatibility with ASDF projects.


asdf-converter.lisp
-------------------

OUT-OF-DATE: should be rewritten as part of our refactoring.

This file contains the code to take an asdf system
and write a BUILD.lisp file for it
and add module forms to the top of all the source files in the system,
so that XCVB can now be used to compile the system.

The entry point to this file is the function ASDF-TO-XCVB.
It take as a parameter one SYSTEM or a list of several SYSTEMS
to merge and convert together so they may be built with XCVB.
The converter will first use ASDF-DEPENDENCY-GROVEL
to compute the actual dependencies within your system(s),
thus generating a list of components;
then it will then process that list of components
and create or update a BUILD.lisp and update all source files
to insert a module statement,
keeping any manual rules from a previously added module statement
but otherwise overriding the main data.


main.lisp
---------

The main entry file.

TODO: after the refactoring, add some proper command-line interface.



Good places to extend XCVB
==========================

(1) The generic function create-dependency-node-from-type allows you
to specify a keyword that can be put in a dependency list in a module form.
The create-dependency-node-from-type method
with an eql specifier on that keyword
should create the appropriate dependency-graph-node.

(2) The defextension macro allows you to define a function that can be
called via a keyword in the appropriate place in a module declaration.


Notes
=====

Fullnames
---------

A fullname is used as a unique name
to specify a component in the system.
Both modules and nodes have fullnames --
usually a node will have the same fullname as the module it was generated from
modulo a different file extension.


Eager vs Lazy Module Scanning
-----------------------------

There are two ways that the search path may be search for modules,
and we have to choose early on because of the naming implications.

In the eager scanning approach,
the search paths are scanned for BUILD modules
at the beginning of the build session,
avoiding recursion into version control repositories
or other excluded patterns.

In the lazy scanning approach, the search paths are scanned
only when a specific module is requested,
and the path to scan relative to directories in the search path
can be deduced trivially from the module specification,
so only a small number of candidate paths need to be searched
at any time.

In the eager approach,
the mapping from module name to pathname could be arbitrary,
developers or system integrators
would be free to organize their sources as they wish
and could easily override installed modules
with the specific versions they need,
without having to mimic a standard installation
by moving things around or by using symlinks.
Significant long hierarchical names could be used
to disambiguate modules globally
(but shorter nicknames could also be used if non-ambiguous).
What would make a module toplevel would be the fact
that it declares such a fullname.
The downside would be that eager scanning
introduces two levels of complexity.
The first complexity is this naming indirection,
whereby the whole hierarchy of installed modules
would have to be scanned at every build,
or a cache of the module map would have to be maintained
with timestamp information.
The second complexity is the fact that eager scanning
requires lazy evaluation of the scanned modules,
least the whole Lisp world needs be planned for
(and conflicts resolved) everytime anything is built;
it must be possible to extract naming information from
the module declarations without evaluating any of the
computations required to otherwise make sense of the module.

The lazy approach is much simpler,
at the cost of constraining developers and/or system integrators
to agree on a file hierarchy for their modules.
This cost seems to be paid happily by developers of
Perl, OCaml, Python, PLT Scheme, and many more languages,
so it isn't that high.
In this approach, what makes a module toplevel is simply that
it's located at the top of a directory in the search-path.

The lazy approach allows to better scale to compilation of software
using larger sets of libraries when each piece of software only
uses a small subset of the libraries.
It corresponds to what ASDF currently does.
However, it seems harder to program,
especially if we are to scan whole filesystem hierarchies
and still handle conflicts gracefully;
it is harder to configure if we are to avoid symlinks all over the place
without forcing things into a centralized hierarchy like other languages do;
and it opens a larger window to race conditions
creating unpredictable behaviour if libraries are
tweaked in the middle of a run.

On the other hand, the eager approach seems to better fit
the destructured way that Common Lispers currently work
with respect to filesystem organization (as with other topics)
and may be a double pain (socially speaking) to first reject
then to retrofit after the fact if we find it's required.
Attila Lendvai notably favors the eager approach
(which was also my initial reflex).


Random Remarks
--------------

On the choice of IOLib vs CL-FAD to access files,
I decided that fixing CL-FAD is an uphill battle whereas extending IOLib isn't (so far):
to fix CL-FAD, I need to fix it once per implementation,
with a growing number of implementations and interactions with many system-dependent variants;
to fix IOLib, I need to fix it once per OS,
with a dwindling number of relevant OSes, and
with implementation interactions already handled by CFFI.
So, if we ever port XCVB to anything else than Unix,
the correct way will be to grow Windows (and JVM, Genera) support in IOLib.
See my rant "Who's responsible for that moving part?":
http://fare.livejournal.com/139755.html

TODO
----

For issues and TODO items, see TODO.rest.
