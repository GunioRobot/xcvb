.. ; -*- mode:rst; -*-

==============
XCVB Internals
==============

This file describes the current internals of XCVB.

Unless you check it out as of an official release as tagged in git,
it may or may not be up to date.

(As massive refactoring is underway, this document is found lacking.
Send inquiries to the mailing-list if you need it to be updated.)


.. contents::
..
    1  Current Files
      1.1   driver.lisp
      1.2   pkgdcl.lisp
      1.3   macros.lisp
      1.4   utilities.lisp
      1.5   specials.lisp
      1.6   grains.lisp
      1.7   computations.lisp
      1.8   portablish-pathnames.lisp
      1.9   registry.lisp
      1.10  lisp-grain.lisp
      1.11  names.lisp
      1.12  search-path.lisp
      1.13  dependencies-interpreter.lisp
      1.14  static-backends.lisp
      1.15  string-escape.lisp
      1.16  lisp-invocation.lisp
      1.17  makefile-backend.lisp
      1.18  asdf-converter.lisp
      1.19  main.lisp
    2  Good places to extend XCVB
      2.1  Enriching the dependency language
      2.2  Dynamic XCVB extensions
    3  Notes
      3.1  Fullnames
      3.2  Eager vs Lazy Module Scanning
      3.3  Filesystem Access
      3.4  TODO


Current Files
=============

General TODO: once the API we actually need stabilizes, remove cruft.

driver.lisp
-----------

A small collection of utilities to be compiled into buildee processes
so as to provide an abstraction layer for XCVB to compile files.

Assuming ASDF is already loaded, the driver will also include
ASDF-specific extensions, including the ability to load ASDF systems
and to determine whether or not ASDF systems need to be re-compiled.

Therefore, you must make sure to load ASDF *before* the driver
if you want the XCVB to properly support ASDF in the target system.


pkgdcl.lisp
-----------

This file creates the XCVB package and exports the necessary symbols.

TODO: before we release, edit this file and make sure that
we export all those defined symbols that we want users to use,
and only those symbols.


macros.lisp
-----------

A collection of general-purpose macros.

TODO: Most of them should be moved to a library that XCVB would depend upon.


utilities.lisp
--------------

A collection of utility functions.
Also defines many conditions.

TODO: move conditions to another file.

TODO: Most utilities should be moved to a library that XCVB would depend upon.


specials.lisp
-------------

A collection of global variables,
many of which can be used to customize the behavior of the user-visible parts XCVB.


grains.lisp
-----------

Definition of the main datastructures of XCVB and helper functions.

Grains are nodes in the planning graph representing
files, phonies or transient states,
and as far as the Makefile backend goes, correspond to Makefile targets.

For other backends, grains may be a more general state,
including things like "a running image where such libraries are loaded".
They are named "grains" after reading
'BUILD: A tool for maintaining consistency in modular systems'
by Richard Elliot Robbins, 1985.
ftp://publications.ai.mit.edu/ai-publications/pdf/AITR-874.pdf


computations.lisp
-----------------

Computations are nodes in the planning graph
representing computations that thake some grains as input
and create some other grains as output.
In the Makefile backend, they correspond to the Makefile rules.


portablish-pathnames.lisp
-------------------------

Abstraction layer to ensure that XCVB uses reasonably portable names when naming modules.

Everywhere that hierarchical module names are involved,
XCVB uses the "``/``" character as a pathname directory separator,
in a way that is guaranteed to work portably, however things may vary depending on
Lisp implementation, Operating system, pathname host and device.
Also, XCVB will only accept module names where all characters are valid: ``[-_.,A-Za-z0-9]``.

We might eventually be using some existing library for dealing with namestrings sensibly,
mostly bypassing the unreliable CL pathnames.
Stelian Ionescu may be working on something like that soon for zeta-streams.
In the meantime, we'll use our own library portablish-pathnames
to get rid of these non-portable things.


registry.lisp
-------------

Handles the mapping from fullname to grain,
and conflicts when multiple BUILDs claim the same name.


lisp-grain.lisp
---------------

Handles parsing module forms in lisp grains,
including the naming of other modules within a module form.


names.lisp
----------

Handles the mapping from file to fullname and fullname to file.
This includes recursing in the case that the fullname is
inherited from a BUILD.lisp up the filesystem tree.


search-path.lisp
----------------

Handles the search path where XCVB goes looking for available BUILDs.
Shell variable ``XCVB_PATH`` or Lisp variable ``xcvb:*search-path*``.


dependencies-interpreter.lisp
-----------------------------

Support for making sense of the XCVB dependency mini-language,
independently from the backend being used.


static-backends.lisp
--------------------

Builds a static graph, for use with GNU Make, ASDF, and other static backends.


string-escape.lisp
------------------

Handles escaping strings, for use in shell invocations and/or
``Makefile`` commands.


lisp-invocation.lisp
--------------------

Handles the invocation of the target lisp system,
abstracting away the differences between implementations.


makefile-backend.lisp
---------------------

This is our new makefile backend,
iterating over computations to create Makefile rules.


asdf-converter.lisp
-------------------

MAYBE OUT-OF-DATE: should be rewritten as part of our refactoring.

This file contains the code to take an asdf system
and write a BUILD.lisp file for it
and add module forms to the top of all the source files in the system,
so that XCVB can now be used to compile the system.

The entry point to this file is the function ASDF-TO-XCVB.
It take as a parameter one SYSTEM or a list of several SYSTEMS
to merge and convert together so they may be built with XCVB.
The converter will first use ASDF-DEPENDENCY-GROVEL
to compute the actual dependencies within your system(s),
thus generating a list of components;
then it will then process that list of components
and create or update a BUILD.lisp and update all source files
to insert a module statement,
keeping any manual rules from a previously added module statement
but otherwise overriding the main data.


main.lisp
---------

The main entry file.

TODO: make the command-line interface self-documenting.
Add support for ASDF to XCVB migration from this interface.


Good places to extend XCVB
==========================

Enriching the dependency language
---------------------------------

To extend our dependency language, edit ``dependencies-interpreter.lisp``.
The first thing you'll need is a way to normalize a user-specified dependency
into something that isn't relative to the grain in which the dependency appears.
Then, you'll need to add functions in ``static-backends``
to handle graph nodes for grains that correspond to your normalized names.
You may add more backend-independent functions in
``dependencies-interpreter.lisp``.
Backend-independent means that your code will hopefully still work
when non-Makefile backends are added in the future.
Finally, you'll need to enrich ``makefile-backend.lisp``
with some support to output those graph nodes.
Along the way, you may have to modify more files,
maybe create an additional one for your feature.


Dynamic XCVB extensions
-----------------------

We have reserved a place for "extension forms" in the module syntax,
but we don't have any serious infrastructure for taking advantage of it yet.

Hence the "X" of "XCVB" is mostly a lie at this time.
Unless by "extensible" we trivially mean that
it's free software written in a dynamic language so
users can extend it in whatever way they want, whenever they want.
Furthermore, some of the internals are indeed made to be extended,
by using the ``define-simple-dispatcher`` infrastructure.


Notes
=====

Fullnames
---------

A fullname is used as a unique name
to specify a component in the system.
Both modules and nodes have fullnames --
usually a node will have the same fullname as the module it was generated from
modulo a different file extension.


Eager vs Lazy Module Scanning
-----------------------------

There are two ways that the search path may be search for modules,
and we have to choose early on because of the naming implications.

In the eager scanning approach,
the search paths are scanned for BUILD modules
at the beginning of the build session,
avoiding recursion into version control repositories
or other excluded patterns.

In the lazy scanning approach, the search paths are scanned
only when a specific module is requested,
and the path to scan relative to directories in the search path
can be deduced trivially from the module specification,
so only a small number of candidate paths need to be searched
at any time.

In the eager approach,
the mapping from module name to pathname could be arbitrary,
developers or system integrators
would be free to organize their sources as they wish
and could easily override installed modules
with the specific versions they need,
without having to mimic a standard installation
by moving things around or by using symlinks.
Significant long hierarchical names could be used
to disambiguate modules globally
(but shorter nicknames could also be used if non-ambiguous).
What would make a module toplevel would be the fact
that it declares such a fullname.
The downside would be that eager scanning
introduces two levels of complexity.
The first complexity is this naming indirection,
whereby the whole hierarchy of installed modules
would have to be scanned at every build,
or a cache of the module map would have to be maintained
with timestamp information.
The second complexity is the fact that eager scanning
requires lazy evaluation of the scanned modules,
least the whole Lisp world needs be planned for
(and conflicts resolved) everytime anything is built;
it must be possible to extract naming information from
the module declarations without evaluating any of the
computations required to otherwise make sense of the module.

The lazy approach is much simpler,
at the cost of constraining developers and/or system integrators
to agree on a file hierarchy for their modules.
This cost seems to be paid happily by developers of
Perl, OCaml, Python, PLT Scheme, and many more languages,
so it isn't that high.
In this approach, what makes a module toplevel is simply that
it's located at the top of a directory in the search-path.

The lazy approach allows to better scale to compilation of software
using larger sets of libraries when each piece of software only
uses a small subset of the libraries.
It corresponds to what ASDF currently does.
However, it seems harder to program,
especially if we are to scan whole filesystem hierarchies
and still handle conflicts gracefully;
it is harder to configure if we are to avoid symlinks all over the place
without forcing things into a centralized hierarchy like other languages do;
and it opens a larger window to race conditions
creating unpredictable behaviour if libraries are
tweaked in the middle of a run.

On the other hand, the eager approach seems to better fit
the destructured way that Common Lispers currently work
with respect to filesystem organization (as with other topics)
and may be a double pain (socially speaking) to first reject
then to retrofit after the fact if we find it's required.
Attila Lendvai notably favors the eager approach
(which was also my initial reflex).


Filesystem Access
-----------------

We currently use standard CL functions such as DIRECTORY to find BUILD files.

We don't use CL-FAD because it is broken,
and fixing it is an uphill battle that requires code for each implementation,
each time with many system-dependent variants.

If we ever require deeper access to the filesystem
(e.g. to manipulate timestamps, symlinks, etc.),
we should be using IOLib.
IOLib is not perfect, but to fix it you only need code for each OS,
and there is a dwindling number of relevant OSes;
implementation interactions are already handled by CFFI.
So, if we ever port XCVB to anything else than Unix,
the correct way will be to grow Windows (and JVM, Genera) support in IOLib.
See my rant "Who's responsible for that moving part?":
http://fare.livejournal.com/139755.html


TODO
----

For issues and TODO items, see TODO.rest.
