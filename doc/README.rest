.. ; -*- mode:rst; -*-

===================================================================
XCVB - an eXtensible Component Verifier and Builder for Common Lisp
===================================================================

The goal of this project is to have a scalable system
to build large software in Common Lisp,
featuring deterministic separate compilation and
enforced locally-declared dependencies.


.. Contents::
..
    1  About XCVB
      1.1  Status
      1.2  Home page
      1.3  Dependencies
      1.4  Documentation
      1.5  Timeline
    2  Using XCVB
      2.1  Building XCVB
      2.2  Starting a new XCVB project
      2.3  Compiling with XCVB
      2.4  Lisp Setup
      2.5  Interactive update of a running image with XCVB master
    3  Restrictions on your Lisp Code
      3.1  Compile-time side-effects
      3.2  Full library needed at compile-time
      3.3  Optimization settings
    4  Combining Multiple Projects
      4.1  Module Full Names
      4.2  Search Path
      4.3  Module Name Resolution
      4.4  Dumping Images
    5  Additional Features
      5.1  Lisp file generation
      5.2  Data Dependencies
      5.3  Conditional Dependencies
      5.4  Warning Control
      5.5  CL:REQUIRE
    6  Troubleshooting an XCVB build
      6.1  Debugging the built system
      6.2  Debugging the build
      6.3  Profiling the build
    7  XCVB and ASDF
      7.1  XCVB builds depending on ASDF systems
      7.2  ASDF systems depending on XCVB builds
      7.3  Converting XCVB builds into ASDF systems
      7.4  Converting ASDF systems into XCVB builds
      7.5  ASDF extensions without XCVB equivalent
      7.6  Undoing a conversion to XCVB
      7.7  Fast non-enforcing builds using POIU


About XCVB
==========

Status
------

Bottom line:
XCVB is available as a working deterministic build system for Common Lisp.
It isn't yet ready as a full replacement for ASDF for the Lisp masses.

The current version (in git master branch or the release tarball)
can handle builds of very large and complex systems,
though it is not very user-friendly in its failure modes.

You can either write your project directly as an XCVB build
or automatically convert an existing ASDF project
(manual work required if ASDF extensions are used).
XCVB will then help you create a ``Makefile`` for your project,
whereby it can be compiled in a way that enforces declared dependencies.
You may even compile in parallel with ``make -j``
which on a SMP machine may end up being faster than ASDF.

XCVB builds can depend on other builds and/or on ASDF systems.
ASDF systems can be superseded by incrementally migrated XCVB builds when available,
for better dependency management.

Hopefully a version 1.0 will be released at the end of this year
that can seriously replace ASDF and provide a migration path.


Home page
---------

The home page of the project is at:

	http://common-lisp.net/project/xcvb/

You can find a tarball containing XCVB, all its dependencies, and a few generated files
sufficient to bootstrap the whole thing (depending on CLISP or SBCL with or without CFASL) in:

           http://common-lisp.net/project/xcvb/releases/

You can checkout our public repository with::

	git clone http://common-lisp.net/project/xcvb/git/xcvb.git

Or if you are a project member, you can obtain write access using::

	git clone ssh://USER@common-lisp.net/project/xcvb/git/xcvb.git

You can also browse the repository at either of these:

	http://common-lisp.net/gitweb?p=projects/xcvb/xcvb.git

	http://github.com/fare/xcvb/tree/master

We also have two mailing-lists, one reserved for announcements,
``xcvb-announce`` http://www.common-lisp.net/mailman/listinfo/XCVB-announce
and one open to general discussions,
``xcvb-devel`` http://www.common-lisp.net/mailman/listinfo/xcvb-devel


Dependencies
------------

As mentioned above, you can find a tarball with all dependencies
sufficient to bootstrap XCVB at:

           http://common-lisp.net/project/xcvb/releases/

You will still need a Lisp implementation to build and run XCVB itself,
and to build and run the target software that you will build with XCVB:

  * We develop mainly with SBCL (CFASL support is included in SBCL 1.0.30.4 or later):
	- homepage: http://sbcl.sourceforge.net/
	- CLiki page: http://cliki.net/SBCL
        - get it from: http://sbcl.sourceforge.net/platform-table.html

  * We also make our best to keep it running with the following other Lisp implementations:
	- Clozure CL: http://ccl.clozure.com/
	- GNU CLISP: http://clisp.cons.org/

  * We unhappily haven't had resources to port it to other implementations yet,
    but porting should hopefully be easy:
    you can grep for e.g. ``clozure`` to find the few spots where
    there are implementation dependencies, and flesh out
    some variant for your favorite implementation there.
    We will assist you, and may even do it for you if we have access
    to the implementation on top of which you are interested in using XCVB.

If you prefer to collect XCVB's dependencies manually into your system,
you will need the following Lisp software libraries to get XCVB running:

  * cl-launch 2.29 or later:
	- homepage: http://cliki.net/CL-Launch
	- getting it:
		``git clone http://common-lisp.net/project/xcvb/git/cl-launch.git``
        - getting it, if you're an XCVB project member::
        	``git clone ssh://USER@common-lisp.net/project/xcvb/git/cl-launch.git``

  * ASDF 1.367 or later:
	- homepage: http://cliki.net/asdf
	- getting it:
		``git clone http://common-lisp.net/project/asdf/asdf.git``
        - getting it, if you're an ASDF project member:
		``git clone ssh://USER@common-lisp.net/project/asdf/asdf.git``

  * Our fork of ``asdf-dependency-grovel``:
	- homepage: http://cliki.net/asdf-dependency-grovel
	- getting it:
		``git clone http://common-lisp.net/project/xcvb/git/asdf-dependency-grovel.git``
        - getting it, if you're an XCVB project member:
		``git clone ssh://USER@common-lisp.net/project/xcvb/git/asdf-dependency-grovel.git``

  * Closer to MOP, with our trivial XCVB-readiness patch:
	- homepage: http://common-lisp.net/project/closer/closer-mop.html
	- getting it for now:
		``darcs get http://www.common-lisp.net/project/xcvb/darcs/closer-mop``
	- getting it, once the XCVB patch has been accepted upstream:
		``darcs get http://www.common-lisp.net/project/closer/darcs/closer-mop``

  * command-line-arguments:
	- homepage: http://common-lisp.net/project/qitab/
	- getting it:
		``git clone http://common-lisp.net/project/qitab/git/command-line-arguments.git``
        - getting it, if you're a QITAB project member::
        	``git clone ssh://USER@common-lisp.net/project/qitab/git/command-line-arguments.git``

  * POIU:
	- homepage: http://common-lisp.net/project/qitab/
	- getting it:
		``git clone http://common-lisp.net/project/qitab/git/poiu.git``
        - getting it, if you're a QITAB project member::
		``git clone ssh://USER@common-lisp.net/project/qitab/git/poiu.git``

Additionally, our XCVB master mode
(see below `Interactive update of a running image with XCVB master`_)
currently requires
the utility ``tthsum`` to be installed
so as to compute identifying cryptographic hashes of your files.
If you cannot install this utility, be sure to disable XCVB master support
when you use our Makefile backend, using option ``--no-master``.
If you are using Debian or Ubuntu, you may install it with::

	sudo apt-get install tthsum


Documentation
-------------

``doc/README.rest``
	The present file describes how to currently use XCVB.

``doc/xcvb.rest`` ``doc/ilc09-xcvb.rest`` ``doc/ilc09-xcvb-slides.rest``
	These files should provide with an overview of the project,
	its intended benefits, rationale and general design.

``doc/ilc09-xcvb-paper.tex`` ``doc/xcvb.bib`` ``doc/sigplanconf.cls``
	These source files compile to a PDF for the demonstration
        that was presented at ILC'2009 for XCVB.

``doc/INTERNALS.rest``
	This file is an introduction to the internals of XCVB
        for hackers interested in debugging or extending it.

``doc/TODO.rest``
	The many prioritized TO DO items on our plate to improve XCVB.
        Some already implemented items should be moved to current documentation.

``doc/configure.mk.example``
	example file to copy into ``configure.mk`` (in the main XCVB directory) and edit,
	so as to be able to create the ``xcvb`` executable.

``Makefile``
	the Makefile for XCVB itself is an example for how to integrate XCVB in your Makefile.
        Note that the setup.lisp complexity is only required if you're using ASDF.


Timeline
--------

The original idea for what became XCVB is due to James Knight,
in 2007 discussions about the failure of POIU and ASDF-DEPENDENCY-GROVEL
to yield a *maintainable* alternative to serial ASDF systems
for the QRes project at ITA Software.

XCVB was originally written by Spencer Brody under the supervision of
Francois-Rene Rideau from late May to mid August 2008.
The result was a working prototype,
but lacking in features and requiring some layer of manual hacks
specific to the target on which XCVB was run.

Francois-Rene Rideau restarted work on it
and released in mid December 2008
a version of the prototype where the above hacks were automated away.
A paper about the prototype was presented at ILC'09.
The prototype can be retrieved in the git branch ``v0.1-prototype``::

	git pull http://common-lisp.net/project/xcvb/git/xcvb.git v0.1-prototype:v0.1-prototype
	git checkout v0.1-prototype

Francois-Rene Rideau then undertook a complete rewrite of XCVB
to make its architecture more general and actually extensible
building on the lessons of the prototype.
A semi-usable product was published in May 2009,
and usable release tarballs have been produced since July 2009,
with notable contributions from Joyce Chen and Matthew Steele.

In late August 2009, we released XCVB 0.366
which successfully compiled a large system at ITA.

We are working hard towards making a 1.0 release
usable by random Common Lisp programmer by the end of 2009.

Subscribe to one of our mailing-lists
if you're interested in learning about our progress
or in influencing our design.


Using XCVB
==========

You may want to checkout the latest XCVB from git.
We'll tag stable releases when there are some.


Building XCVB
-------------

The simple way to build XCVB is to use our release tarballs,
and just follow the instructions in the ``INSTALL`` file.

The hard way to build XCVB is to install all the dependencies as listed above,
then create and edit your own ``configure.mk`` from ``doc/configure.mk.example``.
You'll notably need to configure those dependencies to work with ASDF:
typically, you'll create somewhere a ``systems/`` directory,
in which you'll create a symlink to each of the ``.asd`` files in your dependencies,
and in your ``configure.mk`` tell ``cl-launch`` to use said directory
with an appropriate ``--path`` option.
You can now to bootstrap XCVB using ASDF with ``make xcvb-using-asdf``.
If successful, you may finally complete the bootstrap of XCVB using XCVB itself,
by exporting the proper ``XCVB_PATH`` and then invoking ``make xcvb``.

Assuming you installed ``xcvb`` into some directory in your ``$PATH``,
you can test that XCVB built correctly by using the following query commands::

	xcvb version
	xcvb show-search-path


Starting a new XCVB project
---------------------------

The general principle is that every Lisp file starts with a form like::

       #+xcvb (module (:depends-on ("packages" "macros" "specials" "foo")))

That form specifies all the dependencies of the Lisp file
and nothing but its dependencies.
Optionally, you can distinguish
between ``:compile-depends-on``
and ``:load-depends-on``
and even ``:cload-depends-on``:


 * ``:load-depends-on`` specifies what must be loaded the compiled FASL file may be loaded.
 * ``:compile-depends-on`` specifies what must be loaded before the Lisp file may be compiled
   (by default, the compile-time versions of the files listed in ``:load-depends-on`` above;
   where compile-time version is a CFASL if available, or else a FASL).
 * ``:cload-depends-on`` specifies what must be loaded before the compiled CFASL file may be loaded
   when compiling files that depend on it, assuming CFASLs are available
   (by default, the same as ``:compile-depends-on`` above;
   it should probably always be a subset thereof).
 * ``:depends-on`` specifies what must be loaded no matter what in all the above cases.

Finally, a main file called ``build.xcvb``
is the main file that needs to be loaded in the final image.
It is typically empty except for the module form specifying
all its dependencies
and possibly some finalization forms to run at the end of the build.
The dependencies typically include ASDF libraries,
currently specified in an ugly way as dependencies of the build image.
The ``build.xcvb`` file for Exscribe_ is as follows::

	#+xcvb
        (module
          (:fullname "fare.tunes.org/exscribe"
           :nicknames ("exscribe")
           :supersedes-asdf ("exscribe")
           :build-depends-on ("/cl-launch" "/fare-utils"
                              "/fare-matcher" "/scribble"
                              (:asdf "cl-typesetting"))
           :depends-on ("scheme-compat" "exscribe"
                        "exscribe-html" "exscribe-txt" "exscribe-typeset")
           :pre-image t
           :build-image t))

You don't need to specify all your files in the ``build.xcvb`` module form,
only those containing the functions you really care about,
since the load dependencies will be automatically identified and loaded.


Compiling with XCVB
-------------------

To compile with XCVB,
you first need to have XCVB generate a ``Makefile`` for your project
with the ``make-makefile`` command,
then to invoke ``make(1)`` with this ``Makefile``.

A simple example would be::

	xcvb make-makefile --build /foo/bar --lisp-implementation sbcl

Where ``/foo/bar`` is the fullname of your target
(usually a build, but can be a single Lisp module).

Note that you need to properly setup your `Search Path`_ with ``XCVB_PATH``,
or specify it with option ``--xcvb-path``.
Also, XCVB will assume that the specified implementation,
``sbcl`` or otherwise, is in your ``PATH``, though you may override with
``--lisp-binary-path``.
If needed, make sure you export the proper
``SBCL_HOME`` or ``CCL_DEFAULT_DIRECTORY``, etc.,
or that some wrapper script to your Lisp binary does.

The default name for said generated ``Makefile``
is actually ``xcvb.mk`` in the current directory,
but you can override either or both of this name and that directory
with the ``--output-path`` option to ``make-makefile``.

For a correct build, it is recommended that you should run
the ``xcvb make-makefile`` command before every time you build,
in case any dependency has changed due to some modification.
XCVB should be fast and this shouldn't be a problem.
If making the Makefile takes more than a few seconds,
there's probably a performance bug and you should contact us.

After obtaining your ``xcvb.mk``, you may invoke ``make(1)``
using this output file in the following way::

	make -f xcvb.mk -j obj/foo/bar.image

Where ``obj`` is the object directory
(which can be overridden with option ``--object-directory`` of ``make-makefile``),
``-j`` specifies a parallel build (also see ``make`` option ``-l``),
and ``foo/bar.image`` would be the name of the image for your project
(assuming its build has fullname ``/foo/bar`` and declares ``:build-image t``.)

From the image, you can create an executable with such a command as::

	cl-launch --lisp sbcl --image obj/foo/bar.image \
		--output bar --dump ! --restart 'bar::main'

As an example of how to put it all together, see
XCVB's own ``Makefile``,
or the ``Makefile`` of exscribe_.

.. _exscribe: http://www.cliki.net/exscribe


Lisp Setup
----------

It is often useful or necessary to setup your target Lisp system
before you start to compile files and build images with it.

Such setup may include
proclaiming optimization settings, (see below `Optimization Settings`_),
loading and configuring ASDF (see below `XCVB builds depending on ASDF systems`_),
configuring variables that control your Lisp implementation,
selecting compiler warnings you want to silence (see below `Warning Control`_),
pushing ``*features*`` for conditional compilation based on some environment variables,
initializing some pathname translation layer such as logical pathnames,
loading specialized handlers for ASDF-DEPENDENCY-GROVEL when it is used,
configuring or extending the XCVB driver itself,
etc.,
to name a few things that have been done as part of ITA Software's build.

The setup file is specified with option ``--setup`` to ``xcvb make-makefile``,
followed by the fullname of an XCVB Lisp module,
following usual XCVB naming conventions.
For instance, assuming your project has fullname ``/foo/bar``,
you may create an XCVB module called ``setup.lisp`` under your build directory,
and specify ``--setup /foo/bar/setup`` as arguments to ``xcvb make-makefile``.

By default, XCVB will start the build by dumping an image
starting from the specified implementation binary and image,
and loading the XCVB driver followed by any setup you specified.
This is often useful for performance reasons
if your setup is non-trivial, or
if there will be a large number of files being compiled from the initial setup
(because their respective builds do not otherwise specify or inherit a pre-image).
There are cases however, for instance in a small project with a trivial setup,
where you will prefer to eschew the automating dumping of this initial base image
(especially on implementations where dumping is much slower than loading FASLs,
such as CCL).
In these cases, you pass to ``xcvb make-makefile`` the option
``--no-base-image``.


Interactive update of a running image with XCVB master
------------------------------------------------------

``/xcvb/master`` is a small standalone Lisp file.
It allows you to build some Lisp software cleanly in a subprocess
then load the results into the current image.

When you call ``xcvb-master:build-and-load``
(which also has the short-hand ``xcvbm:bnl``),
it will use ``run-program`` to invoke a slave XCVB process
that will drive all the compilation out-of-image
then reply to the master with a specification of files to load.
The function takes as arguments the name of a build and a flurry of options.
The build specifies what you want to update;
the options precisely match those of ``xcvb make-makefile``.

The slave will complete the build then reply with a list of files to load,
including a TTH_ checksum of each file (currently using the external utility ``tthsum``)
so the master can skip the files of which the very same version has already been loaded.
The slave will do all the cryptographic hashing on its side,
so you don't have to include crypto libraries in your image --
or anything beside the simple and short xcvb-master.

.. _TTH: http://en.wikipedia.org/wiki/Hash_tree#Tiger_tree_hash

By default XCVB will include the master and provide initial configuration of it
in any build you make with the Makefile backend,
unless you explicitly specify ``--no-master``
(which really is only useful for bootstrapping XCVB itself).
Even then, you can explicitly include it in your software by
specifying a dependency on ``/xcvb/master``,
though it might not be initially configured by XCVB
if you compiled with the ``--no-master`` flag
or with the ASDF/POIU backend.

You can also include the XCVB master in an ASDF build as system ``xcvb-master``
or load it as a Lisp file from a bare image with
``(load "/path/to/xcvb/master.lisp")``
as an alternative to using ``asdf.lisp`` to drive further compilations.

The XCVB master can advantageously replace ASDF, as it has a much smaller footprint,
doesn't pollute the current process with artefacts of compilation
or the compilation with the artefacts of the current process,
doesn't have as many multithreading concurrency issues as compiling in-process can raise,
and preserves determinism and reusability in the FASL files being built.

Note that if you built your Lisp image using ASDF,
either directly with ADSF (possibly with files from our ASDF backend),
or with our current non-dependency-enforcing build,
then XCVB master will basically rebuild and reload everything
using our enforcing backend.
However you can use the usual ASDF mechanisms to update your system as usual.
If you used our non-enforcing backend, you currently have to regenerate
a new image from the command-line, then use ASDF to reload the system
in your current image
(TODO item: we hope to provide automation for that in a further version of XCVB).

Note that the usual restrictions apply as to any update of a running Common Lisp image:

  * errors may happen if you change a symbol's nature
    between lexical, special, constant or symbol-macro as a variable,
    or between simple function, generic function or macro as a function.

  * errors may happen if you change the signature of a generic function,
    the definition of a structure type, if you fail to provide appropriate
    methods on ``update-instance-for-redefined-class``, etc.

  * side-effects may override your variables (such as from ``setf`` or ``defparameter``).

  * the order in which side-effects happen or fail to happen
    (as XCVB master skips files an identical copy of which was already loaded)
    can trigger subtle bugs in your code
    (watch any compile-time dictionaries your code may use).

More generally, the correct loading a file may implicitly require
pre-conditions that are valid in a clean build,
but violated in an incremental load.
Some of these issues can be worked around by manually uninterning specific symbols,
clearing and rebuilding dictionaries or twiddling specific entries,
unregistering and re-registering specific hooks,
deleting and re-creating specific packages, etc.
(see for instance the ``/xcvb/no-asdf``).
Unhappily, there is no general solution to this problem,
and that we know, no declarative meta-level protocol
was devised to help alleviate it.


Restrictions on your Lisp Code
==============================

Compile-time side-effects
-------------------------

To conform with the CLHS_ (see `section 3.2.2.3`_),
any ``defun``, ``defvar`` or other side-effect
must be effected in the compilation environment
to be available for use in macros,
while compiling either the current file or any further file.
This means that these effects should be enclosed in an
``(eval-when (:compile-toplevel :load-toplevel :execute) ...)``.
(See on my blog a discussion of `eval-when`_.)

.. _CLHS: http://www.lispworks.com/documentation/HyperSpec/Front/index.htm
.. _section 3.2.2.3: http://www.lispworks.com/documentation/HyperSpec/Body/03_bbc.htm
.. _eval-when: http://fare.livejournal.com/146698.html

Respecting that constraint will allow for
faster recompilation (where CFASLs are available),
since CFASLs may be smaller and faster to load than FASLs,
and subject to less variation which may trigger fewer recompilations.
It will also allow for easier cross-compilation
and more generally situations where the target image
should be different from compilation environment,
which was no doubt a strong motivating factor
behind this constraint being made part of the standard to begin with.
And of course, you can have a stronger claim of standard compliance.

This constraint is both enforced and taken advantage of
when you use the CFASL option of XCVB.
This option is enabled by default on implementations that support it,
currently only SBCL
(but there are plans for Clozure CL to support it if and when XCVB takes off).

When you use this option, ``(:compile "foo")`` dependencies
turn into ``(:cfasl "foo")`` and specify that the specified CFASL will be loaded.
(This is what ``"foo"`` expands into for ``:compile-depends-on``
as explicitly specified or inherited from ``:depends-on``);
your effects will then be available if and only if you used
``:compile-toplevel`` in your ``eval-when``.
When you don't use this option ``(:compile "foo")`` dependencies
turn into ``(:fasl "foo")`` and specify that the specified FASL will be loaded instead;
your effects will then be available if and only if you used
``:load-toplevel`` in your ``eval-when``.
Finally, some other programs (notably ASDF-DEPENDENCY-GROVEL) will load your source code
at which point your effects will be available if and only if you used
``:execute`` in your ``eval-when``.
Therefore, any form whose effects must be available in the compilation environment
*must* be enclosed in ``(eval-when (:compile-toplevel :load-toplevel :execute) ...)``.
Other forms can be used without ``eval-when``, which is the same as enclosing them in
``(eval-when (:load-toplevel :execute) ...)``.

Note that this differs notably from ASDF.
On the one hand, ASDF always loads the FASL before it compiles more things,
so you don't need an ``eval-when`` around functions that are only used by macros
when these macros are expanded in a subsequent file rather than the same file.
On the other hand, ASDF doesn't support loading CFASLs, so that effects that only
happen at compile-toplevel are lost during an incremental compilation.

Finally, neither FASL nor CFASL includes
read-time or macroexpansion-time side-effects,
except as materialized in the resulting code as read then expanded.
Therefore to preserve incremental compilation with either XCVB or ASDF,
you must not rely on such side-effects to have been effected
outside of the file where they happen,
unless you also include them in the expansion.


Full library needed at compile-time
-----------------------------------

Sometimes, you actually want the full run-time power
of a library to be available at compile-time,
rather than only the definition of its macros and other usual compile-time side-effects.

You can achieve this by including your required dependencies in the
``:build-depends-on`` option of your ``build.xcvb``,
or the ``:compile-depends-on`` option of your Lisp module
(and possibly the ``:cload-depends-on`` option).

Indeed, when you specify a dependency in a ``:depends-on`` clause,
the dependency will be added to the load dependencies of the module
as if by ``:load-depends-on``,
and the compile-time-only version of the dependency (if available)
will be added to the compile dependencies of the module,
as if by ``:compile-depends-on``.
For instance, a ``:depends-on (... "foo" ...)`` will specify
a load-time dependency on ``(:fasl "foo")`` and
a compile-time dependency on ``(:cfasl "foo")``.

Note however that nothing is done to prevent both the FASL and CFASL to be loaded,
in any order implicit in the transitive dependencies of a module.
This can cause interesting surprises if any of those compile-time side-effects
are not idempotent, and/or if loading the CFASL resets some work done by the FASL.
Consider notably the proper use of ``defvar`` vs ``defparameter`` at compile-time.


Optimization Settings
---------------------

Amongst compile-time side-effects, a notable one is the optimization settings.
A default may to be set in your initial Lisp image setup
(see above section `Lisp Setup`_)
by modifying the variable ``xcvb-driver:*optimization-settings*``.
For instance, your setup file may include::

	(setf xcvb-driver:*optimization-settings* '(optimize (speed 1) (safety 3)))

Modules that want to change these settings
from this default specified for the compilation of just one file
can ``declaim`` it, or
``(eval-when (:compile-toplevel :load-toplevel :execute) (proclaim ...))`` it,
or (more portably) ``(locally (declare ...) ...)`` it.
You may define some macro that does that for you,
that you will call at the beginning of relevant files.

Note however that using ``declaim`` or ``proclaim`` may or may not
have a different meaning in other build systems (e.g. ASDF)
depending on implementations.
Some implementations (like SBCL) will confine ``declaim`` settings
and ``:compile-toplevel`` ``proclaim`` settings to the current file,
while other implementations (like CCL, Allegro)
will leak them to subsequent files,
whereas ``:load-toplevel`` ``proclaim`` settings
will usually leak to subsequent files when you load the FASL.

This non-determinism is against the spirit of XCVB, and
XCVB resets optimization settings to the declared default
before each and every command issued to load or compile any file.
When using ASDF, we have similarly been in the habit,
which we recommend others to follow, to similarly reset optimization settings
in a ``asdf:perform`` method ``:before`` or ``:around``
the relevant operations
(and we'll push for such method to be standardized in the upstream ASDF).


Combining Multiple Projects
===========================

Module Full Names
-----------------

XCVB relies on a global namespace for developers to name modules.
Using this namespace allows programmers to name modules independently
from their specific location on any particular machine's filesystem.

Thus each hierarchy of XCVB files contains a top-level ``build.xcvb`` file.
This file contains a module declaration with a ``:fullname`` initializer
that specifies a prefix name for all modules in the hierarchy.
E.g. if your directory ``/foo/bar/`` has a file ``build.xcvb``
containing the specification ``:fullname "lisp.example.com/quux"``
then all files under this file hierarchy will be considered as being under
the hierarchy ``lisp.example.com/quux`` within the global module namespace,
unless overridden by a lower ``build.xcvb``.
Thus, a file ``/foo/bar/baz/toto.lisp`` would inherit the fullname
``lisp.example.com/quux/baz/toto``.

Nicknames are also allowed, and the same ``build.xcvb`` could declare
the nickname ``quux`` and the same file would then be accessible
under the shorter name ``quux/baz/toto``.

Note that everywhere that hierarchical module names are involved,
XCVB uses the "``/``" character as a pathname directory separator,
in a way that is guaranteed to work portably, however things may vary depending on
Lisp implementation, Operating system, pathname host and device.
Also, XCVB will only accept module names where all characters are valid: ``[-_.,A-Za-z0-9]``.
XCVB build names are case-sensitive (unlike ASDF names)
but it is strongly suggested to respect the current convention
of using all lowercase names.
Finally, XCVB assumes that Lisp files have type ``lisp`` as far as pathnames are considered.


Search Path
-----------

To map names to files on the current machine,
XCVB relies on the user having properly configured its search path.

The search path is stored in the Lisp variable ``xcvb:*search-path*``
that has a (hopefully) sensible default and
can otherwise be configured through
environment variables, configuration files, or
(in the near future) command-line arguments.

  1- When XCVB starts, it initializes ``xcvb:*search-path*`` to its default,
  by evaluating function ``xcvb::default-search-path`` which evaluates
  and returns the following::

    (list
      *default-pathname-defaults*
      (subpathname (user-homedir-pathname) "lisp/")
      #p"/usr/local/share/common-lisp/source/"
      #p"/usr/share/common-lisp/source/"))

  2- If environment variable ``XCVB_PATH`` is set,
  it is read as a "``:``"-delimited list of path strings,
  wherein an entry "``!``" means "splice the previous value".

  3- (In the future) If a command-line argument is specified with ``--path``
  then it is interpreted with the same behavior as above.

  4- Your Lisp configuration or command file may arbitrarily modify
  special variable ``xcvb:*search-path*``
  by prepending and/or appending more pathname designators.

Before XCVB actually tries to process any module,
it will finalize its search path by eliminating all invalid paths
from *search-path* and eagerly collecting a list of all the top-level
``build.xcvb`` files under the specified filesystem hierarchies.
For this reason, you will want to include as narrow directory hierarchies
as you can in the search path. ``/opt/share/common-lisp/source/``
is probably good, whereas ``/`` or ``/usr`` may result in minutes or hours
being spent searching your whole filesystem in vain.

Conflicts between two ``build.xcvb`` files
claiming the same name or nickname are resolved as follows:
if one ``build.xcvb`` appears in a hierarchy
that appears earlier in the search path, then it takes precedence;
if the previous rule doesn't disambiguate a name, then
said name will be marked as a conflict and
will be unavailable for use during the build.
To avoid gratuitous conflicts,
subdirectories named ``_darcs`` or ``.svn``
are conspicuously not searched.

Importantly, an installed version of XCVB itself
(at least its ``build.xcvb`` and ``driver.lisp`` in the same directory)
must be present under the search path
since XCVB will look for the module ``/xcvb/driver``
to be included in the target Lisp image as a necessary prelude to any build.

In a good installation of XCVB, this should be the case by default,
and users would use ``!`` in their search path specifications
to inherit this default;
however, until XCVB comes packaged with your system,
you shouldn't trust these defaults until you have verified them.

You can query your current search path with the command::

	xcvb search-search-path

Also available is the short-hand ``xcvb ssp``.

_`Note to people migrating from ASDF`_:
this more or less corresponds
to the ``asdf:*central-registry*`` special variable.
However, whereas ASDF relies on lazy dereference of symlinks
and doesn't descend into subdirectories,
XCVB eagerly scans subdirectories and registers available builds.
XCVB works with or without symlinks.


Module Name Resolution
----------------------

When a module form refers to another module, it may use a short name.
The algorithm by which a name reference is resolved to a full name is as follows.

First, names that start with a ``/`` character are absolute names,
and always refer to the global module namespace.
When resolving an absolute name,
the registered build with the longest matching path prefix is identified.
If it is not found, or if there are several conflicting
build files with that same fullname, then an error is raised.
Otherwise, the rest of the name after stripping the prefix is used as
a pathname relative to the identified build.

Second, names that are not absolute are relative names.
Attempt is successively made to resolve them
relative to the current build and each of its ancestors.
Failing that, they are resolved as absolute names as above.


Dumping Images
--------------

Each build may specify with ``:build-image t``
that an image should be dumped after the build is completed.
This is most useful in your toplevel build to prepare an image
from which you'll latter build an executable with ``cl-launch``,
as explained in section `Compiling with XCVB`_.

Each build may also specify with ``:pre-image t``
that an image should be dumped before the build itself is started,
containing all the dependencies specified with ``:build-depends-on``.
This can notably speed up compilation if your build
has both a lot of build dependencies and a lot of files,
as compared to leaving this unspecified
in which case all these many dependencies will be re-loaded
before the compilation of each and every file in your build.

In any case, whenever it compiles a build,
XCVB will try to reuse an existing image if any is available,
based on the first dependency.
Therefore, to maximize image reuse, make sure that the first dependency
listed in a build's ``:build-depends-on`` is itself
a build that has a post- or pre- image
that already includes as many dependencies as possible,
in which case your build will inherit an image from the former build.


Additional Features
===================

Lisp file generation
--------------------

XCVB supports the dynamic generation of Lisp files.

Statements of generated files are to be included amongst the
"extension forms" of your ``build.xcvb`` file,
i.e. after the list of keyword options
``(:fullname ... :depends-on ...)``.

Here is the syntax::

	(:generate
         ((:lisp "lists"
           :depends-on ("conditions" "util" "specials" "packages"))
          (:lisp "hash-tables"
           :depends-on ("lists"))
          (:lisp "methods"
           :depends-on ("api" "hash-tables")))
         :depends-on ("build/dump"))

In this example declaration, excerpted from ``cl-unicode``,
``"lists"``, ``"hash-tables"``, and ``"methods"``
are files that are generated by loading ``"build/dump"``.
Each ``(:lisp ...)`` statement takes a name,
then a list of keyword option as in a Lisp module specification.
A grain for a Lisp module will thus be assumed,
with the specified name relative to the current build.
Dependencies for this module will be
as specified statically from these keyword options.
and not deduced dynamically from the contents of the file once created
(indeed these contents may lack a module statement altogether).
To build the specified Lisp files, the dependencies specified in
the ``:depends-on`` argument will be loaded.
These dependencies may usefully include in the end
a statement like ``(:call :my-package :my-function)``
to call a function to be defined in previously loaded dependencies,
or like ``(:eval-string "(arbitrary lisp expression)")``
to evaluate some arbitrary Lisp expression.

Also note that if your file is to be computed by some arbitrary shell command
that does not reduce to the loading of a Lisp file, then
XCVB doesn't currently support the explicit specification of such a thing;
however you can instead insert such a dependency directly in your ``Makefile``
as below, have that ``Makefile`` include your ``xcvb.mk``,
and invoke ``make(1)`` with that ``Makefile``::

	version.lisp: version.text
		echo "(in-package :foo)(defparameter *version* \"$$(cat version.text)\")" > $@
	include xcvb.mk


Data Dependencies
-----------------

XCVB supports the declaration of dependencies on data files
during the building of some targets.

Here is the current temporary syntax::

	(:depends-on ("build/read" "build/char-info" "build/util" "util" "specials" "packages")
         :load-depends-on ((:source "build/data/BidiMirroring.txt")
                           (:source "build/data/Blocks.txt")
                           (:source "build/data/DerivedAge.txt")
                           (:source "build/data/Jamo.txt")
                           (:source "build/data/PropList.txt")
                           (:source "build/data/Scripts.txt")
                           (:source "build/data/UnicodeData.txt")))

This example, excerpted from ``cl-unicode`` shows how
loading the current module ``build/dump``
depends on bunch data files in ``build/data``.


Conditional Dependencies
------------------------

XCVB supports the specification of conditional dependencies
using the following syntax for dependencies:

	``(:when (:featurep (:or :sbcl :cmu)) "pcl")``

When such a dependency is specified, the module named ``"pcl"``
(relative to the current build's fullname) will be included
when and only when the target Lisp implementation has the feature
``:sbcl`` or the feature ``:cmu``, i.e. is SBCL or CMUCL.

Note that XCVB does *not* support CL-style conditional reading with
``#+`` and  ``#-`` within the ``(module ...)`` form.
Instead the form is read in a dynamic context
where ``*features*`` has been bound to ``'(:xcvb)``.
Indeed, read-time conditionals lose information at read-time
whereas XCVB purports to build a faithful model of the whole build,
from which one could e.g. extract a list of source files.


Warning Control
---------------

XCVB provides a simple way to specify which compiler conditions (style-warnings, etc.)
to show to the user and which to muffle.
This feature is very useful to make sure that warnings the user cares about are caught,
whereas those considered as noise are filtered out.

This feature is defined in ``driver.lisp`` (fullname ``/xcvb/driver``),
the one file included in all target images by XCVB.
You may modify the special variable ``xcvb-driver:*uninteresting-conditions*``
in the file you specify through XCVB's ``--setup`` option.

How to identify compiler conditions is specific to your Lisp implementation.
Typically you may have to grep the sources of said implementation to find
a condition type or a simple-condition's format-control string.
In more advanced cases, you may can define your own predicate to
discriminate the conditions you're looking to keep or eliminate.


CL:REQUIRE
----------

Any dependency of the form ``(:require :foo)`` will be interpreted as
the need to call ``CL:REQUIRE`` to load the implementation-dependent feature ``:foo``.
The argument can be a string or a keyword, and is usually written
as an upper-case string or a lower-case keyword (which will be case-converted).

These things are implementation-dependent, and so often used in conjunction
with ``:when`` or ``:cond``.
For instance, such popular components
include ``:sb-posix`` and ``:sb-bsd-sockets`` under SBCL.
In your ``build.xcvb`` you would use::

	:depends-on (... (when (:featurep :sbcl) (:require :sb-posix)) ...)

In ASDF, you might either call ``#+sbcl (require :sb-posix)`` directly in the ``.asd`` file,
or rely on these features also having a corresponding ASDF definition
and specify in your ``defsystem`` form::

	:depends-on (... #+sbcl :sb-posix ...)

In this case, the same trick of depending on ``(:asdf :sb-posix)`` in your ``build.xcvb`` may work.

If you need some magic side-effects before or after requiring the feature,
you are better off doing it in your `Lisp setup`_ file.

Finally, if you are requiring this feature in a Lisp file that may be loaded directly
as well as built as part of a larger system,
then you may also have to do things the hard way:
include the following in your initial package definition file,
after your ``(cl:in-package :cl-user)`` statement,
and before any ``(defpackage ...)`` clause that may import
anything defined by the required feature::

	(eval-when (:compile-toplevel :load-toplevel :execute)
          #+sbcl (require :sb-posix))


Troubleshooting an XCVB build
=============================

Debugging the built system
--------------------------

Assuming your system builds, you may want to debug it with SLIME_.

.. _SLIME: http://common-lisp.net/project/slime/

If you build an image, you can load it with::

	C-u M-x slime sbcl --core obj/mybuild.image

If you build an executable, you can have it offer a REPL like XCVB does
(see the implementation of ``xcvb repl`` in ``xcvb/main.lisp``) and use::

	C-u M-x slime env SBCL_HOME=/usr/lib/sbcl xcvb repl

You can then use ``C-c C-c`` to compile definitions you modify,
or ``C-c C-k`` to compile whole files.
When you're satisfied with the changes you've made interactively,
you should check that it still builds from clean with ``make``,
and use the REPL interactively once again to double check
that it still does what you think it does.


Debugging the build
-------------------

When you encounter an issue in the build itself,
you can try to restart the offending compilation
with debugging enabled.
To enable debugging,
define the shell variable ``XCVB_DEBUGGING`` as some non-empty string
and export it.

The standard way to do that would be to build your software with::

	make -j -f xcvb.mk || XCVB_DEBUGGING=t make -f xcvb.mk

This will automatically invoke a debugging build of the first failing component
when an error is found, otherwise happily compiling your system in parallel.

What the ``XCVB_DEBUGGING`` variable does is cause the
the ``xcvb-driver:debugging`` primitive to be called.
If you want to do in-depth debugging as you initially port things to XCVB,
you can also call this function in your Lisp setup.


Profiling the build
-------------------

If you want to understand where exactly the build is spending its time,
you can define the shell variable ``XCVB_PROFILING`` as a non-empty string
and export it.

This will cause the XCVB driver to output lines of timing information
that you can thereafter read and analyze.


XCVB and ASDF
=============

XCVB builds depending on ASDF systems
-------------------------------------

You may in some ``(module ...)`` declaration include a dependency on ``(:asdf "foo")``
which XCVB will interpret as requiring the loading of such an ASDF
with ``(asdf:oos 'asdf:load-op "foo")``.

However, if amongst your dependencies there are any ASDF systems
that haven't yet been converted to XCVB,
then you'll probably need a setup file (as per `Lisp Setup`_)
to load ASDF and configure its ``*central-registry*``.

In simple cases, your personal ``setup.lisp`` may be as simple as the following::

	(in-package :cl-user)
	(require :asdf)
        (push "/path/to/my/asdf/systems/" asdf:*central-registry*)

In slightly harder cases, you may call ``cl-launch`` to the rescue::

	cl-launch --lisp clisp --path /path/to/my/asdf/systems -B print_lisp_setup > setup.lisp

XCVB's own ``Makefile`` includes a target to build a ``setup.lisp``
using the same principle, but additionally leveraging the pre-existing
``cl-launch`` configuration that was used for compiling XCVB itself
(when bootstrapped with ASDF).

In yet harder cases, a robust semi-portable ``setup.lisp``
may contain the usual ASDF hackery, including such snippets as::

	(in-package :cl-user)
        (eval-when (:compile-toplevel :load-toplevel :execute)
          (defun get-env-var (x)
            #+sbcl (sb-ext:posix-getenv x)
            #+clozure (ccl:getenv x))
          (defparameter *l* (make-pathname :name nil :type nil :defaults *load-pathname*)))
        (eval-when (:compile-toplevel :load-toplevel :execute)
          (unless (and (find-package :asdf) (find-symbol "SYSTEM" :asdf))
            (block asdf-load
              (handler-bind
                  ((error #'(lambda (c)
                              (declare (ignore c))
                              (load (merge-pathnames "libs/asdf/asdf.lisp" *l*))
                              (return-from asdf-load nil))))
                (require :asdf)))))
        (eval-when (:compile-toplevel :load-toplevel :execute)
          (let* ((asds (directory (merge-pathnames #P"**/*.asd" *l*)))
                 (asd-dirs (remove-duplicates (mapcar #'pathname-directory asds) :test #'equal)))
             (dolist (subdir asd-dirs)
               (unless (search '("_darcs" "pristine") subdir :test #'equal)
                 (pushnew (namestring (make-pathname :directory subdir)) asdf:*central-registry*
                          :test #'equal))))
          (let ((use-poiu (get-env-var "USE_POIU")))
            (when (and use-poiu (not (equal use-poiu "")))
              (pushnew :parallel-build *features*))
              (unless (find-symbol "PARALLEL-LOAD-OP" :asdf)
                (asdf:oos 'asdf:load-op :poiu))))


ASDF systems depending on XCVB builds
-------------------------------------

A current limitation of ASDF is that
ASDF systems cannot at this time depend on XCVB builds.

However, you can easily extract an ASDF system from one or more XCVB builds,
and use that as a system that other ASDF systems may depend upon.
(See `Converting XCVB builds into ASDF systems`_ below.)
Or you can use a manually maintained ``.asd`` file that covers
the same software as an XCVB build.

Now, there may at this point be "interesting" situations
where some software is loaded both as an ASDF system and an XCVB build.
Say, some XCVB build A depends on an ASDF system B
that depends on an ASDF system C, while some other XCVB build D
depends on same software C but as an XCVB build.
In such case, the XCVB build will redundantly compile and load
the same software a second time after it has been loaded by ASDF.
Apart from the slight performance penalty, things should be alright.
But if your ASDF central registry and your XCVB search path
are configured to compile slightly different and incompatible versions,
you may experience bugs. So make sure there is no conflict there.
Finally, if some kind of deep conflict bites you because somehow
ASDF and XCVB compile your software incompatible, it won't be loaded twice,
the best solution will be to fix your software,
and possibly convert all the relevant dependencies to use XCVB
(in the above notional example, convert B to XCVB).

As a kluge, if you really don't want to convert such system to XCVB,
you may hack your XCVB ``build.xcvb`` specifications
to specify dependencies on such software as ``(:asdf "foo")``
instead of ``(:build "foo")`` or ``"foo"`` or ``"/foo"``,
and/or plainly comment them out if said dependencies are loaded as part of your ``setup.lisp``.
If you specify ``(:asdf "foo")``,
you may want to take any ``build.xcvb`` that ``:supersedes-asdf ("foo")``
out of your ``XCVB_PATH``, and/or create a conflict for it,
and/or comment out said ``:supersedes-asdf`` declaration.

Contact the authors of XCVB if any help is required.


Converting XCVB builds into ASDF systems
----------------------------------------

It is possible to automatically convert one or more XCVB builds into an ASDF system.

This can be used to allow ASDF-based toolchains to depend
on software packaged with XCVB
(see above `ASDF systems depending on XCVB builds`_).

This can also allow XCVB-enabled software to be built faster
(because without dependency enforcement) with ASDF or POIU,
all the while being able to enforce and check dependencies as part of development.
However see below `Fast non-enforcing builds using POIU`_
for how such use has been integrated in XCVB.

The conversion is automatic, but "flattens" features
that are not supported by ASDF without an extension:

  * Generated files will be not be marked specially on the ASDF side;
    it is assumed that by the time the dependencies have been compiled and loaded,
    the generated files will be there.
    Recent versions of ASDF should be satisfied with that.

  * Conditional dependencies are expanded according to the implementation specified for XCVB.
    As a limitation of our automated conversion process, we don't try to convert conditionals
    such as ``(:when (:featurep :sbcl) ...)`` into the idiom ``#+sbcl ...``
    (because the general case is not completely trivial and would require us
    to rewrite our own pretty printer).

  * Require dependencies must somehow be provided
    (e.g. by having the ``.asd`` file or some Lisp file call ``(cl:require ...)``
    with the desired feature before the feature is used;
    possibly in an ``EVAL-WHEN`` at the beginning of the file where the feature is used.)

If you are using a simple build that does not using any such extensions to ASDF,
then the produced ASDF file will be a faithful representation of the XCVB build.
If you use any such extension, then the produced ASDF file will be but an extract
that will allow you to compile your software with the specified implementation,
but will not constitute a general ASDF file unless you edit it by hand
to make proper use of ASDF extensions.

To convert, use a command such as::

	xcvb xcvb-to-asdf \
        	--build /fullname/of/some/build
                --build /fullname/of/some/other/optional/build
                --name desired-name-of-asdf
                --output-path /element/of/an/output/path.asd

See ``xcvb help xcvb-to-asdf`` for more options for this command.


Converting ASDF systems into XCVB builds
----------------------------------------

In simple cases, you may convert a system from ASDF to XCVB with a command such as::

	xcvb asdf-to-xcvb \
                --setup /path/to/lisp/file/to/setup/asdf/if/not/builtin/to/your/lisp \
		--system-path /path/to/your/asdf/systems/ \
		--system-path /path/to/more/asdf/systems/ \
                --preload some-system-to-preload-and-not-instrument \
                --preload another-system-to-preload-and-not-instrument \
                --preload yet-another-system-to-preload-and-not-instrument \
                --system main-system \
                --system another-system-to-merge-with-it \
                --system yet-another-system-to-merge-with-it


In cases where the above fails, common pitfalls include the following:

  * If your system has conditional dependencies (as in ``#+sbcl ...``) then
    you'll have to manually add such dependencies
    to the ``:depends-on`` of the proper XCVB module,
    or possibly as part of your ``:build-depends-on``.

  * If your system has some generated files, then you'll have to add the
    proper entries manually in your ``build.xcvb``.
    On the other hand, you won't have to reimplement in XCVB
    the kludges that were necessary to have that work under ASDF (kind of),
    for XCVB has built-in and correctly working support for such generated files.

  * If some of your files have data dependencies,
    the converter may get confused by any ASDF extension used for this purpose,
    and you may have to either convert manually, or strip down your ``.asd`` file
    into something that ASDF-DEPENDENCY-GROVEL may understand,
    then add data dependencies by hand.
    To conditionally modify your ``.asd`` file, you may use ``#+asdf-dependency-grovel``
    or otherwise do conditional compilation based on some symbol that you ``push`` into
    ``*features*`` in your setup file.

  * If your system requires some other ASDF extension,
    this isn't yet supported by XCVB, and you will have to manually convert any such thing.
    Please also contact the authors of XCVB.

  * If your files define compile-time datastructures, you may have to
    either extend ``asdf-dependency-grovel`` to support your defining primitives
    (see the ``handlers/`` directory of ASDF-DEPENDENCY-GROVEL),
    or to manually use ADG's ``signal-provider`` and ``signal-user`` functions
    to manually declare otherwise undetected dependencies.

  * If your system includes magic build-time side-effects inside the ``.asd`` file itself,
    then you'll have to provide any such effects in a different way with XCVB.
    For instance, you may include any required ``(pushnew ... *features*)`` in an ``eval-when``
    near the top of your package definition file,
    or in a Lisp file at the end of your build,
    or even in your `Lisp Setup`_ file.

Additionally, figuring out the dependencies between your Lisp modules
may not suffice to obtain a system that compiles with XCVB.
You will still have to edit your code so that it follows the
`Restrictions on your Lisp Code`_, most notably regarding the proper usage of ``eval-when``.


ASDF extensions without XCVB equivalent
---------------------------------------

``ASDF-BINARY-LOCATIONS`` (now part of ASDF as of 1.366)
redirects the FASLs in a shared per-user cache with discriminations per implementation
(CL-Launch does something similar).
XCVB segregates FASLs per project, as you may have different image setup
(including optimization options, feature set, etc.) for different project,
and want to ensure 100% determinism and reproducibility
of the build of each of your critical projects,
without possible side-effects from unrelated projects.

``ASDF-SYSTEM-CONNECTIONS`` allows you to declare "connection" systems
that are magically loaded when all of their dependencies are loaded.
Reported use include automatically loading debugging support for some systems
when `SLIME`_'s swank is loaded.
This doesn't have an XCVB equivalent, and
probably will never have an equivalent inside XCVB,
although similar functionality can be trivially implemented as a layer that wraps XCVB.
Indeed, XCVB is wholly based upon the "pure functional" idea
that a dependency means the same thing
independently from the other components of the overall system in which it is included.
``ASDF-SYSTEM-CONNECTIONS`` doesn't save you from having to specify
a connected system with both dependencies
just because it calls this system "connection".
In programs that actually make use of the connection,
it isn't harder to specify an explicit dependency on the connected system
than to specify both dependencies,
and it is much less confusion-prone.
Making such dependencies explicit also allows to clearly distinguish
and manipulate the smaller components that are connected and
the bigger component that includes and connects them.
With XCVB, you are welcome to define "connections",
and automatically generate specifications that include "connected" systems,
but this has to happen in a layer above XCVB
that XCVB itself doesn't have to care about;
for instance, in a script that will parse some specification
and select which modules of your big system will be included in your build,
and do any kind of rule-based reasoning it wants to automatically include connections.
This script can then create a ``build.xcvb`` file and instruct XCVB to build it.


Undoing a conversion to XCVB
----------------------------

If for whatever reason, you want to undo the conversion to XCVB, you can use::

	xcvb remove-xcvb --build /mybuild

And it will remove the ``build.xcvb`` file and
all ``#+xcvb (module ...)`` forms from your Lisp files.

Even if you want to keep using XCVB in the future,
this can be useful to get a patch of all the non-XCVB modifications you had to do
(like inserting ``EVAL-WHEN``'s and fixing some evil macros)
to get the software running, and commit them (or send them upstream) separately.
Just be sure to keep your XCVB modifications in a backup, branch, committed baseline, etc.,
if you don't want to have to redo them manually.


Fast non-enforcing builds using POIU
------------------------------------

After our initial experiments with the Makefile backend of XCVB,
it appeared that enforcing dependencies in such a naive way
can lead to build times that is an order of magnitude slower
than a serial build time with ASDF, even a quad-core machine.

If you have a very large body of Lisp code,
you can use the non-enforcing backend of XCVB to build it fast
in parallel with ASDF or POIU::

	xcvb nm --build stage1 --build stage2 --build foo --parallel
        make -f xcvb-ne.mk

This will create a non-enforcing Makefile (default name ``xcvb-ne.mk``)
that plainly creates a series of images for each of the builds,
culminating with the last one, where for each stage
the dependencies are compiled with ASDF,
or with POIU if the ``--parallel`` option is specified.

Note that depending on your machine, your Lisp implementation and your project,
compilation in parallel with POIU can be either much faster or somewhat slower
than compilation in series with ASDF.
The best way to figure it out is to try them both and see what suits you best.

See ``xcvb help non-enforcing-makefile`` for more options for this command.

This backend provides fast compilation for your big projects,
though you may want to at least keep the slower enforcing compilation running
as part of your pre-release tests to detect and debug missed dependencies,
thus keeping the compilation speed of ASDF or POIU,
while getting the flexibility, safety and maintainability that XCVB brings.

Finally, note that POIU only supports SBCL and CCL at this time.
If you are using another implementation, you should either use ASDF
or extend POIU to support your implementation.
